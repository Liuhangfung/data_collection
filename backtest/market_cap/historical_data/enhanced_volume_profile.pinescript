// Â© Enhanced Volume Profile Pro
// Advanced Volume Profile with Multi-Timeframe Analysis, Delta Detection, and Smart Levels
// This work builds upon volume profile concepts with significant enhancements

//@version=5
indicator("Enhanced Volume Profile Pro", "EVP Pro", true, max_boxes_count=500, max_lines_count=500)

//---------------------------------------------------------------------------------//
//                            ENHANCED USER SETTINGS                              //
//---------------------------------------------------------------------------------//

// --- Core Profile Settings ---
var g_core = "--- Core Profile Settings ---"
lookback = input.int(300, "Lookback Bars", minval=50, maxval=2000, group=g_core, tooltip="Number of bars to analyze for the profile")
profileType = input.string("Enhanced Money Flow", "Profile Type", options=["Volume", "Money Flow", "Enhanced Money Flow", "Delta"], group=g_core, tooltip="Enhanced Money Flow uses VWAP-weighted calculations")
rows = input.int(30, "Profile Rows", minval=15, maxval=100, step=5, group=g_core)
autoRows = input.bool(true, "Auto-Adjust Rows", group=g_core, tooltip="Automatically adjust rows based on volatility")

// --- Multi-Timeframe Analysis ---
var g_mtf = "--- Multi-Timeframe Analysis ---"
enableMTF = input.bool(true, "Enable Multi-Timeframe", group=g_mtf)
higherTF = input.timeframe("4H", "Higher Timeframe", group=g_mtf)
showTFComparison = input.bool(false, "Show TF Comparison", group=g_mtf)

// --- Advanced Volume Analytics ---
var g_analytics = "--- Advanced Analytics ---"
showVolumeWaves = input.bool(true, "Volume Wave Analysis", group=g_analytics, tooltip="Detect volume accumulation and distribution waves")
showSmartLevels = input.bool(true, "Smart Support/Resistance", group=g_analytics, tooltip="AI-detected levels based on volume concentration")
volumeAnomalyDetection = input.bool(true, "Volume Anomaly Detection", group=g_analytics)
showInstitutionalFlow = input.bool(false, "Institutional Flow Estimate", group=g_analytics)

// --- Enhanced Visuals ---
var g_visuals = "--- Enhanced Visuals ---"
profileStyle = input.string("Gradient", "Profile Style", options=["Solid", "Gradient", "Heat Map"], group=g_visuals)
showVolumeOscillator = input.bool(true, "Volume Momentum Oscillator", group=g_visuals)
dynamicWidth = input.bool(true, "Dynamic Width", group=g_visuals, tooltip="Adjust profile width based on recent volatility")
baseWidth = input.int(20, "Base Width %", minval=5, maxval=50, group=g_visuals) / 100
transparency = input.int(60, "Transparency", minval=0, maxval=90, group=g_visuals)

// --- Color Scheme ---
var g_colors = "--- Enhanced Colors ---"
highVolumeColor = input.color(color.new(#00ff88, 30), "High Volume", group=g_colors)
averageVolumeColor = input.color(color.new(#3366ff, 50), "Average Volume", group=g_colors)
lowVolumeColor = input.color(color.new(#ff4444, 70), "Low Volume", group=g_colors)
buyingPressureColor = input.color(color.new(#00c851, 40), "Buying Pressure", group=g_colors)
sellingPressureColor = input.color(color.new(#ff3547, 40), "Selling Pressure", group=g_colors)
institutionalColor = input.color(color.new(#ffbb33, 50), "Institutional Flow", group=g_colors)

//---------------------------------------------------------------------------------//
//                            ENHANCED CALCULATION ENGINE                          //
//---------------------------------------------------------------------------------//

// Enhanced volume calculation with VWAP weighting
calcEnhancedVolume(src, vol, mode) =>
    switch mode
        "Volume" => vol
        "Money Flow" => vol * src
        "Enhanced Money Flow" => vol * src * (1 + math.abs(ta.change(src) / src))
        "Delta" => vol * (close > open ? 1 : -1)
        => vol

// Multi-timeframe volume data
[htfHigh, htfLow, htfVolume, htfClose] = request.security(syminfo.tickerid, higherTF, [high, low, volume, close])

// Dynamic row calculation based on volatility
calcDynamicRows() =>
    if autoRows
        volatility = ta.atr(20) / close
        baseRows = 30
        adjustment = math.round(volatility * 1000)
        math.max(15, math.min(100, baseRows + adjustment))
    else
        rows

dynamicRows = calcDynamicRows()

// Volume wave detection
volumeMA = ta.sma(volume, 20)
volumeWave = volume > volumeMA * 1.5

// Smart level detection using volume clustering
var float[] smartLevels = array.new_float()
var int[] smartLevelStrength = array.new_int()

if barstate.islast and showSmartLevels
    array.clear(smartLevels)
    array.clear(smartLevelStrength)
    
    // Detect price levels with high volume concentration
    for i = 0 to lookback - 1
        priceLevel = close[i]
        volumeCluster = 0.0
        clusterCount = 0
        
        for j = math.max(0, i-10) to math.min(lookback-1, i+10)
            if math.abs(close[j] - priceLevel) / priceLevel < 0.002 // Within 0.2%
                volumeCluster += volume[j]
                clusterCount += 1
        
        if clusterCount >= 3 and volumeCluster > ta.sma(volume, 50)[i] * 2
            array.push(smartLevels, priceLevel)
            array.push(smartLevelStrength, clusterCount)

// Main profile calculation (optimized)
if barstate.islast
    // Calculate price range
    profileHigh = high[0]
    profileLow = low[0]
    
    for i = 1 to lookback - 1
        profileHigh := math.max(profileHigh, high[i])
        profileLow := math.min(profileLow, low[i])
    
    priceRange = profileHigh - profileLow
    rowHeight = priceRange / dynamicRows
    
    if rowHeight > 0
        // Initialize enhanced arrays
        var totalVolume = array.new_float(dynamicRows, 0.0)
        var buyVolume = array.new_float(dynamicRows, 0.0)
        var sellVolume = array.new_float(dynamicRows, 0.0)
        var institutionalVolume = array.new_float(dynamicRows, 0.0)
        
        // Clear arrays
        array.fill(totalVolume, 0.0)
        array.fill(buyVolume, 0.0)
        array.fill(sellVolume, 0.0)
        array.fill(institutionalVolume, 0.0)
        
        // Enhanced profile building with optimized loops
        for i = 0 to lookback - 1
            barHigh = high[i]
            barLow = low[i]
            barRange = barHigh - barLow
            barVolume = calcEnhancedVolume(hl2[i], volume[i], profileType)
            
            if barRange > 0 and barVolume > 0
                // Determine market sentiment
                isBullish = close[i] > open[i]
                pressure = (close[i] - low[i]) / (high[i] - low[i])
                
                // Institutional flow estimation (large volume spikes)
                isInstitutional = volume[i] > ta.sma(volume, 20)[i] * 3
                
                // Distribute volume across rows more efficiently
                startRow = math.max(0, math.floor((barLow - profileLow) / rowHeight))
                endRow = math.min(dynamicRows - 1, math.floor((barHigh - profileLow) / rowHeight))
                
                for row = startRow to endRow
                    rowBottom = profileLow + row * rowHeight
                    rowTop = rowBottom + rowHeight
                    
                    overlap = math.max(0, math.min(barHigh, rowTop) - math.max(barLow, rowBottom))
                    if overlap > 0
                        volumePortion = (overlap / barRange) * barVolume
                        
                        array.set(totalVolume, row, array.get(totalVolume, row) + volumePortion)
                        
                        if isBullish
                            array.set(buyVolume, row, array.get(buyVolume, row) + volumePortion)
                        else
                            array.set(sellVolume, row, array.get(sellVolume, row) + volumePortion)
                        
                        if isInstitutional
                            array.set(institutionalVolume, row, array.get(institutionalVolume, row) + volumePortion)
        
        // Find enhanced levels
        maxVolume = array.max(totalVolume)
        pocRow = array.indexof(totalVolume, maxVolume)
        pocPrice = profileLow + (pocRow + 0.5) * rowHeight
        
        // Enhanced Value Area calculation
        totalProfileVolume = array.sum(totalVolume)
        targetVA = totalProfileVolume * 0.70
        
        vaVolume = array.get(totalVolume, pocRow)
        vaTop = pocRow
        vaBottom = pocRow
        
        while vaVolume < targetVA and (vaTop < dynamicRows - 1 or vaBottom > 0)
            topValue = vaTop < dynamicRows - 1 ? array.get(totalVolume, vaTop + 1) : 0
            bottomValue = vaBottom > 0 ? array.get(totalVolume, vaBottom - 1) : 0
            
            if topValue >= bottomValue and vaTop < dynamicRows - 1
                vaVolume += topValue
                vaTop += 1
            else if vaBottom > 0
                vaVolume += bottomValue
                vaBottom -= 1
            else
                break
        
        vaHighPrice = profileLow + (vaTop + 1) * rowHeight
        vaLowPrice = profileLow + vaBottom * rowHeight
        
        //---------------------------------------------------------------------------------//
        //                            ENHANCED DRAWING LOGIC                              //
        //---------------------------------------------------------------------------------//
        
        // Dynamic width calculation
        currentVolatility = ta.atr(20) / close
        dynamicWidthMultiplier = dynamicWidth ? (1 + currentVolatility * 10) : 1
        profileWidthBars = math.round(lookback * baseWidth * dynamicWidthMultiplier)
        
        // Draw Value Area with enhanced styling
        box.new(
            bar_index - lookback, vaLowPrice,
            bar_index, vaHighPrice,
            bgcolor = color.new(averageVolumeColor, 85),
            border_color = color.new(averageVolumeColor, 50),
            border_width = 2
        )
        
        // Draw Point of Control with dynamic width
        line.new(
            bar_index - lookback, pocPrice,
            bar_index, pocPrice,
            color = highVolumeColor,
            width = 3,
            style = line.style_solid
        )
        
        // Enhanced profile bars with gradient effect
        for row = 0 to dynamicRows - 1
            rowBottom = profileLow + row * rowHeight
            rowTop = rowBottom + rowHeight
            rowVolume = array.get(totalVolume, row)
            rowBuy = array.get(buyVolume, row)
            rowSell = array.get(sellVolume, row)
            rowInstitutional = array.get(institutionalVolume, row)
            
            if rowVolume > 0
                volumeRatio = rowVolume / maxVolume
                barLength = volumeRatio * profileWidthBars
                
                // Enhanced color calculation
                baseColor = volumeRatio > 0.8 ? highVolumeColor : 
                           volumeRatio > 0.3 ? averageVolumeColor : lowVolumeColor
                
                finalColor = switch profileStyle
                    "Gradient" => color.new(baseColor, math.round(transparency + (1 - volumeRatio) * 30))
                    "Heat Map" => volumeRatio > 0.7 ? color.new(color.red, 40) :
                                 volumeRatio > 0.4 ? color.new(color.orange, 50) :
                                 color.new(color.blue, 60)
                    => color.new(baseColor, transparency)
                
                // Main volume profile bar
                box.new(
                    bar_index + 5, rowBottom,
                    bar_index + 5 + int(barLength), rowTop,
                    bgcolor = finalColor,
                    border_color = na
                )
                
                // Buying/Selling pressure bars
                if rowBuy > 0 or rowSell > 0
                    sentiment = (rowBuy - rowSell) / (rowBuy + rowSell)
                    sentimentLength = math.abs(sentiment) * barLength * 0.3
                    sentimentColor = sentiment > 0 ? buyingPressureColor : sellingPressureColor
                    
                    box.new(
                        bar_index + 5 + int(barLength) + 2, rowBottom,
                        bar_index + 5 + int(barLength) + 2 + int(sentimentLength), rowTop,
                        bgcolor = sentimentColor,
                        border_color = na
                    )
                
                // Institutional flow indicator
                if showInstitutionalFlow and rowInstitutional > rowVolume * 0.1
                    instRatio = rowInstitutional / rowVolume
                    box.new(
                        bar_index + 5 + int(barLength) + int(sentimentLength) + 4, rowBottom,
                        bar_index + 5 + int(barLength) + int(sentimentLength) + 4 + int(instRatio * 10), rowTop,
                        bgcolor = institutionalColor,
                        border_color = na
                    )
        
        // Draw smart levels
        if showSmartLevels and array.size(smartLevels) > 0
            for i = 0 to array.size(smartLevels) - 1
                levelPrice = array.get(smartLevels, i)
                strength = array.get(smartLevelStrength, i)
                
                line.new(
                    bar_index - lookback, levelPrice,
                    bar_index + 20, levelPrice,
                    color = color.new(color.yellow, 30),
                    width = math.min(strength, 5),
                    style = line.style_dashed,
                    extend = extend.right
                )
        
        // Volume wave markers
        if showVolumeWaves and volumeWave
            label.new(
                bar_index, high,
                text = "ð",
                style = label.style_label_down,
                color = color.new(color.blue, 50),
                size = size.small
            )

//---------------------------------------------------------------------------------//
//                            VOLUME MOMENTUM OSCILLATOR                           //
//---------------------------------------------------------------------------------//

if showVolumeOscillator
    volumeMomentum = ta.rsi(volume, 14)
    
    var table volumeTable = table.new(position.top_right, 2, 4, bgcolor=color.new(color.white, 80), border_width=1)
    
    if barstate.islast
        table.cell(volumeTable, 0, 0, "Volume Momentum", text_color=color.black, text_size=size.small)
        table.cell(volumeTable, 1, 0, str.tostring(math.round(volumeMomentum, 2)), text_color=color.black, text_size=size.small)
        
        table.cell(volumeTable, 0, 1, "Current Vol vs Avg", text_color=color.black, text_size=size.small)
        volRatio = volume / ta.sma(volume, 20)
        table.cell(volumeTable, 1, 1, str.tostring(math.round(volRatio, 2)) + "x", text_color=color.black, text_size=size.small)
        
        table.cell(volumeTable, 0, 2, "Volume Trend", text_color=color.black, text_size=size.small)
        volTrend = ta.sma(volume, 5) > ta.sma(volume, 20) ? "ð" : "ð"
        table.cell(volumeTable, 1, 2, volTrend, text_color=color.black, text_size=size.small)
        
        if volumeAnomalyDetection
            isAnomaly = volume > ta.sma(volume, 50) * 4
            table.cell(volumeTable, 0, 3, "Volume Anomaly", text_color=color.black, text_size=size.small)
            table.cell(volumeTable, 1, 3, isAnomaly ? "â ï¸" : "â", text_color=color.black, text_size=size.small)

// Alerts for significant events
alertcondition(volume > ta.sma(volume, 20) * 3, title="High Volume Alert", message="Significant volume spike detected")
alertcondition(ta.crossover(ta.rsi(volume, 14), 80), title="Volume Overbought", message="Volume momentum overbought")
alertcondition(ta.crossunder(ta.rsi(volume, 14), 20), title="Volume Oversold", message="Volume momentum oversold") 